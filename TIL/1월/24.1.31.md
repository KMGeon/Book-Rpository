### With - cte
- mysql 8.0부터 지원하는 안시 표준이다.
    - 메모리에 임시 결과 셋으로 올려놓고 재사용 ( view , function )
    - 뷰를 만들고 관리의 오버헤드를 줄일 수 있다. -> 유지보수가 쉬워진다.
- (장점) : 순서에 의한 절차적으로 작성이 가능하다 -> 작성이 쉽고 읽기 쉽다.

```
with [recursive ] 
	cte_name[(col_name)] as subquery
select * from cte_name;
```
- mysql의 cte에는 기본 cte를 순차적으로 쿼리가 작성이 가능하고
- 스스로 추가적인 row를 생성할 수 있다.

예시 )
우리는 평균 최소값, 최대값을 구하고 싶습니다.
```sql
select d.DEPTNO, d.DNAME, format(avg(e.SAL)*10000,0) as asal
    from DEPT d inner join emp e
on d.DEPTNO = e.DEPTNO
group by d.DEPTNO
order by asal desc
    union
select d.DEPTNO, d.DNAME, format(avg(e.SAL)*10000,0) as asal
    from DEPT d inner join emp e
on d.DEPTNO = e.DEPTNO
group by d.DEPTNO
order by asal desc;
```
- 다음과 같이 코드를 작성하면 오류가 나옵니다. 왜냐하면 order by는 맨 끝에만 붙을 수 있기 때문에 union에서 에러가 발생을 합니다. 이때 with을 통해서 해결할 수 있습니다.

```sql
WITH
  AvgSal AS (
    select d.dname, avg(e.SAL) avgsal
      from Dept d inner join Emp e on d.DEPTNO = e.DEPTNO
     group by d.DEPTNO
  ),
  MaxAvgSal AS (
    select * from AvgSal order by avgsal desc limit 1
  ),
  MinAvgSal AS (
    select * from AvgSal order by avgsal limit 1
  ),
  SumUp AS (
    select '최고' as gb, m1.* from MaxAvgSal m1
    UNION
    select '최저' as gb, m2.* from MinAvgSal m2
  )
select gb, dname, format(avgsal * 10000,0) from SumUp
UNION
select '', '평균급여차액', format( (max(avgsal) - min(avgsal)) * 10000, 0) from SumUp;
```
- 이를 통해서 원하는 결과를 얻을 수 있습니다. 하지만 이때 임시 메모리를 사용하기 때문에 유의를 해야되고 인덱스를 적절하게 걸어서 성능에 주의를 해야됩니다.


> 그러면 어디에서 장점을 가져갈 수 있나?
- 피보나치나 재귀에서 이점을 가져갈 수 있습니다.

```sql
WITH RECURSIVE cte (n) AS
(
  SELECT 1
  UNION ALL
  SELECT n + 1 FROM cte limit 10
)
SELECT /*+ SET_VAR(cte_max_recursion_depth = 20) */ * FROM cte;

```